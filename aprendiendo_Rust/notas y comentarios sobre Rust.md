# Rust


## Documentaci√≥n por la que comenzar a aprender

### Basic concepts

Two books are key:

- [The Rust Lang Book - The Rust Programming Language](https://doc.rust-lang.org/book/index.html)

- [The Cargo Book - The Rust Package Manager](https://doc.rust-lang.org/cargo/index.html)

It is very paintful to try any work without mastering these three main concepts:

- [Understanding Ownership - The Rust Programming Language](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)

- [The `Option` Enum and Its Advantages Over Null Values](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html?highlight=Option#the-option-enum-and-its-advantages-over-null-values)

- [The `Result` Enum and Error Handling in Rust](https://doc.rust-lang.org/book/ch09-00-error-handling.html)

As in any other language, it is very difficult to do anything serious without using libraries:

- [Rust Crate List - Blessed.rs - an unofficial guide to the Rust ecosystem](https://blessed.rs/crates)

- [Rust Crate List - Docs.rs - the official guide to the Rust ecosystem](https://docs.rs/)

- [Rust std library](https://doc.rust-lang.org/std/)


#### Ownership

Very important to understand it right!

[Understanding Ownership - The Rust Programming Language](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)

[Ownership and Functions](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#ownership-and-functions)

[References and Borrowing](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html)

[Understanding Ownership - Brown University](https://rust-book.cs.brown.edu/ch04-00-understanding-ownership.html)

[Rust Does Not Permit Manual Memory Management](https://rust-book.cs.brown.edu/ch04-01-what-is-ownership.html#rust-does-not-permit-manual-memory-management)

[References and Borrowing](https://rust-book.cs.brown.edu/ch04-02-references-and-borrowing.html)

[RustOwl, a new tool for visualizing Rust lifetimes - Let's Get Rusty - Youtube](https://youtu.be/NV6Xo_el_2o)

[RustOwl tool - Github](https://github.com/cordx56/rustowl)



### Hands-on learning

If you want to start practicing without installing anything, you can try Rust online with (https://play.rust-lang.org/). 

If you want to start serious, install `rustup` (https://doc.rust-lang.org/book/ch01-01-installation.html) and use `cargo` (https://doc.rust-lang.org/cargo/getting-started/first-steps.html). If you are using [Visual Studio Code](https://code.visualstudio.com/download) as IDE, you can use it with the [Rust.analyzer extension](https://rust-analyzer.github.io)

Some resources and tutorials:

[Working the Rust Lang Book](https://www.youtube.com/playlist?list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8) - Let's Get Rusty - YouTube

[Rust by Practice](https://practice.course.rs/)

[Rust By Example](https://doc.rust-lang.org/rust-by-example/index.html)

[Rust Cookbook](https://rust-lang-nursery.github.io/rust-cookbook/intro.html)

[GitHub - mre-idiomatic-rust - ü¶Ä ](https://github.com/mre/idiomatic-rust)
A peer-reviewed collection of articles-talks-repos which teach concise, idiomatic Rust.

[GitHub - rust-lang-rustlings- ü¶Ä ](https://github.com/rust-lang/rustlings)Small exercises to get you used to reading and writing Rust code!

[A half-hour to learn Rust](https://fasterthanli.me/articles/a-half-hour-to-learn-rust)

[Getting started with Rust. A brief Introduction to the language - YouTube](https://www.youtube.com/watch?v=4q3Z5RBX7hQ)

[Learn Rust Programming - Complete Course ü¶Ä - freeCodeCamp - YouTube](https://www.youtube.com/watch?v=BpPEoZW5IiY)

[100 Exercises To Learn Rust](https://rust-exercises.com/100-exercises/)

[google-comprehensive-rust-](https://github.com/google/comprehensive-rust) This is the Rust course used by the Android team at Google. The course covers all aspects of Rust, from basic syntax to generics and error handling. It also includes deep dives on Android, Chromium, bare-metal, and concurrency. [Syllabus](https://google.github.io/comprehensive-rust/)

[Practical Rust Web Development](https://dev.to/werner/practical-rust-web-development-api-rest-29g1)

[Zero To Production in Rust - an opinionated introduction to backend development in Rust](https://www.zero2prod.com/index.html)


#### If you like to program GUI (Graphic User Interface) based programs instead of CLI (Command Line Interface) based ones

Here are some sugestions:

[Are we GUI yet](https://areweguiyet.com/)

[egui - an easy-to-use immediate mode GUI in pure Rust - documentation](https://docs.rs/egui/latest/egui/)

[egui - an easy-to-use immediate mode GUI in pure Rust - Github repository](https://github.com/emilk/egui)

[egui - Getting started with egui in Rust](https://whoisryosuke.com/blog/2023/getting-started-with-egui-in-rust)

[egui - Some sample code - Demo](https://www.egui.rs/#demo)

[iced - A cross-platform GUI library for Rust, inspired by Elm - documentation](https://docs.rs/iced/latest/iced/)

[iced ‚Äì A cross-platform GUI library for Rust, inspired by Elm - Github repository](https://github.com/iced-rs/iced)

[Tauri - Create small, fast, secure, cross-platform applications](https://tauri.app/)

[Are we web yet? - The state of building web applications in Rust](https://www.arewewebyet.org/)

[Yew - A framework for creating reliable and efficient web applications](https://yew.rs/)

[Trunk - Build, bundle & ship your Rust WASM application to the web](https://trunkrs.dev/)

[Building a Rust App With Yew! - Let's Get Rusty - Youtube](https://www.youtube.com/watch?v=KmOeFrwz8BM)


### some additional books and practical resources

[Let's Get Rusty - Youtube channel](https://www.youtube.com/@letsgetrusty)

[Clippy - The Rust Linter](https://doc.rust-lang.org/clippy/)

[rustfmt - A tool for formatting Rust code according to style guidelines](https://github.com/rust-lang/rustfmt)

[The rustup book](https://rust-lang.github.io/rustup/index.html)

[The rustc book](https://doc.rust-lang.org/nightly/rustc/what-is-rustc.html)

[Rust Editions](https://doc.rust-lang.org/nightly/edition-guide/editions/index.html)

[Rust Design Patterns](https://rust-unofficial.github.io/patterns/intro.html)

[Iterators in Rust](https://dev.to/francescoxx/iterators-in-rust-fm)

[Cargo Workspaces](https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html)

[Rust ü¶Ä and WebAssembly üï∏](https://rustwasm.github.io/docs/book/introduction.html)

[mdBook, a command line tool to create books with Markdown](https://rust-lang.github.io/mdBook/)

[The Embedded Rust Book](https://docs.rust-embedded.org/book/)

[The Rusty Bits - Youtube channel](https://www.youtube.com/@therustybits)



### Some additional material to read/view

[Rust Is Easy - just read the compiler error messages  ;-) - YouTube](https://www.youtube.com/watch?v=CJtvnepMVAU)

[Getting familiar with Rust's syntax - YouTube](https://www.youtube.com/watch?v=AuzoABH7fRA)

[Simple error handling in Rust - YouTube](https://www.youtube.com/watch?v=g6WUHcyjsfc)

[The magic of Rust's type system - Youtube](https://www.youtube.com/watch?v=NDIU1GSBrVI)

[Learning Rust: Memory, Ownership and Borrowing - Youtube](https://www.youtube.com/watch?v=8M0QfLUDaaA)

[Why Rust?](https://rerun.io/blog/why-rust)

[Rust stole C++'s best features - YouTube](https://www.youtube.com/watch?v=sjsnuirLyKM)

[pretzelhammer-rust-blog - Github](https://github.com/pretzelhammer/rust-blog/blob/master/posts/tour-of-rusts-standard-library-traits.md)

[5 traits your Rust types must implement](https://www.youtube.com/watch?v=Nzclc6MswaI)

[The genius of Rust constructors - Youtube](https://www.youtube.com/watch?v=6mVkva3_z9M)

[The size of your variables matters - Youtube](https://www.youtube.com/watch?v=hwyRnHA54lI)

[8 deadly mistakes beginner Rust developers make - YouTube](https://www.youtube.com/watch?v=PbR4ECFIckg)

[Top 5 deadly Rust anti-patterns to avoid - YouTube](https://www.youtube.com/watch?v=SWwTD2neodE)

[Common Newbie Mistakes and Bad Practices in Rust](https://adventures.michaelfbryan.com/posts/rust-best-practices/bad-habits/)

## Ownership , Borrow-checker

[Understanding Ownership](https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html)

[Ownership - examples](https://doc.rust-lang.org/rust-by-example/scope/move.html)

[Borrowing - examples](https://doc.rust-lang.org/rust-by-example/scope/borrow.html)

En Rust, todo trozo de memoria es propiedad de una sola variable (el nombre con el que se accede a ese trozo) y ese trozo de memoria es liberado cuando dicha variable deja de existir.

Se puede traspasar esa propiedad, asignando el valor (el trozo de memoria) a otra variable; o pas√°ndola como par√°metro a una funci√≥n (el par√°metro coge la propiedad).

Tambi√©n se puede prestar esa propiedad, incluso a varias propiedades, haciendo que esas otras variables tengan una referencia de solo lectura (&). Pero, en ese caso, ninguna de esas variables podr√° tener una vida (lifetime) m√°s larga que la variable propietaria.


### Move semantics

Este es quiz√° el aspecto que m√°s sorprende a quienes se acercan a Rust por primera vez desde otros lenguajes: cuando una variable se asigna a otra o se pasa como par√°metro a una funci√≥n, pierde el derecho de usar el trozo de memoria al que hacia referencia. La propiedad pasa a esa otra variable o a ese par√°metro.

Hablando en terminologia C: solo puede existir un √∫nico puntero de escritura a cada trozo de memoria reservado.

Esto suele obligar a organizar el c√≥digo de manera diferente a como podamos estar acostumbrados. Cosa que puede resultar algo frustrante al principio. Pero, leyendo atentamente los mensajes de error del compilador y siguiendo sus indicaciones, se suele acabar llegando a una estructura del c√≥digo m√°s clara y l√≥gica de la que hab√≠amos pensado en un primer momento.

nota: Ayuda mucho si previamente estamos acostumbrados al uso de tests unitarios y a trabajar con mentalidad TDD. Esa forma de trabajar suele conducir de manera natural hacia una separaci√≥n clara de responsabilidades entre las distintas partes del c√≥digo, reduciendo las dependencias entre partes. Y esa estructura es la que Rust necesita.


## Strong typed

https://doc.rust-lang.org/book/ch03-02-data-types.html

Rust es un lenguaje "fuertemente tipado". El compilador se encarga de revisar el uso de valores del tipo adecuado en todo momento.

Por ejemplo, en Rust no se pueden sumar un `i32` y un `f32`. Para hacerlo es necesario indicar expresamente cu√°l se convierte de un tipo a otro, para saber con claridad cu√°l ser√° el tipo resultante que se desea.

```
## esta suma:

    let resultado = 5 + 2.3;
    
## produce:

error[E0277]: cannot add a float to an integer
  --> src/main.rs:14:23
   |
14 |     let resultado = 5 + 2.3;
   |                       ^ no implementation for `{integer} + {float}`
   |
   = help: the trait `Add<{float}>` is not implemented for `{integer}`
   = help: the following other types implement trait `Add<Rhs>`:
             <&'a f128 as Add<f128>>
             <&'a f16 as Add<f16>>
             <&'a f32 as Add<f32>>
             <&'a f64 as Add<f64>>
             <&'a i128 as Add<i128>>
             <&'a i16 as Add<i16>>
             <&'a i32 as Add<i32>>
             <&'a i64 as Add<i64>>
           and 56 others

For more information about this error, try `rustc --explain E0277`.
```

Por eso, o bien los tipos resultantes se han de poder inferir con claridad por los tipos participantes en la operaci√≥n, o bien se han de realizar expresamente las conversiones que sean necesarias.

```
    let resultado = 5 + 2.3 as i32;

## o

    let resultado = 5 as f32 + 2.3;
    
## o

    let resultado = 5.0 + 2.3;
```

Parece una tonteria, pero los redondeos en la representaci√≥n interna pueden tener consecuencias en seg√∫n qu√© aplicaciones. 

https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf

Rust nos obliga a pensar en c√≥mo estamos utilizando los valores que manejamos. En las implicaciones que puede tener usar un tipo de representaci√≥n u otro.

En el fondo, los ordenadores  lo reducen todo a valores digitales 0|1 y esas traducciones a binario o desde binario tienen su importancia en seg√∫n qu√© ocasiones.

https://doc.rust-lang.org/book/ch04-03-slices.html?highlight=string#string-slices

https://doc.rust-lang.org/book/ch08-02-strings.html

https://doc.rust-lang.org/book/ch08-02-strings.html#bytes-and-scalar-values-and-grapheme-clusters-oh-my


### Un consejo: definir tipos espec√≠ficos

Una vez acostumbrados al tipado fuerte del propio lenguaje. Podemos ir m√°s all√° y definir tipos espec√≠ficos para nuestra aplicaci√≥n, usando `struct`. 

Los tipos espec√≠ficos tienen una doble ventaja: 
- Permiten referirse a cada cosa por su nombre 
- Evitan errores al pasar valores como par√°metros. 

Por ejemplo: no es lo mismo 
```
    pub fn calcular_precio_del_helado(precio_base: f32, temperatura: f32) -> f32 {
        ((precio_base + temperatura * 0.02) * 100.0).round() / 100.0
    }
```
que
```
    pub struct Temperatura {
        pub cantidad: f32,
    }
    
    pub struct Dinero {
        pub cantidad: f32,
    }
    
    pub fn calcular_precio_del_helado(precio_base: Dinero, temperatura: Temperatura) -> Dinero {
        Dinero {
            cantidad: ((precio_base.cantidad + temperatura.cantidad * 0.02) * 100.0).round() / 100.0,
        }
    }
```

En el primer caso, podr√≠amos confundirnos y pasar el valor de la temperatura como precio y el del precio como temperatura:
```
    println!("{}", calcular_precio_del_helado(75.0, 22.4));
    
    println!("{}", calcular_precio_del_helado(22.4, 75.0));

```


Pero en el segundo caso es mucho m√°s dif√≠cil que eso suceda:
```
    println!(
        "{}",
        calcular_precio_del_helado(Dinero { cantidad: 75.0 }, Temperatura { cantidad: 22.4 })
            .cantidad
    );

    println!(
        "{}",
        calcular_precio_del_helado(Dinero { cantidad: 22.4 }, Temperatura { cantidad: 75.0 })
            .cantidad
    );

```

Adem√°s, definir tipos espec√≠ficos nos permite a√±adir m√°s campos al `struct`, m√°s concreci√≥n en el tipo. Como, por ejemplo, indicando la unidad de medida para cada cantidad.
```
pub struct Temperatura {
    pub cantidad: f32,
    pub unidad_de_medida: UnidadParaMedirTemperatura,
}
pub enum UnidadParaMedirTemperatura {
    Celsius,
    Farenheit,
}

pub struct Dinero {
    pub cantidad: f32,
    pub moneda: Moneda,
}
pub enum Moneda {
    EUR,
    USD,
    CAD,
    GPB,
    JPY,
    RUB,
    RMB,
}
```

Esto permite que el compilador nos ayude. Con errores como, por ejemplo:
```
error[E0063]: missing field `unidad_de_medida` in initializer of `Temperatura`
  --> src/main.rs:18:65
   |
18 |         calcular_precio_del_helado(&Dinero { cantidad: 75.0 }, &Temperatura { cantidad: 22.4 })
   |                                                                 ^^^^^^^^^^^ missing `unidad_de_medida`

For more information about this error, try `rustc --explain E0063`.
```

Estos errores evitan usar datos incompletos. En el ejemplo, el c√≥digo no compilar√≠a hasta indicar las unidades de medida:
```
    println!(
        "{}",
        calcular_precio_del_helado(
            &Dinero {
                cantidad: 75.0,
                moneda: Moneda::EUR
            },
            &Temperatura {
                cantidad: 22.4,
                unidad_de_medida: UnidadParaMedirTemperatura::Celsius
            }
        )
        .cantidad
    );
```

Otro ejemplo:
```
pub fn componer_saludo_formal(tratamiento: &str, apellido1: &str, apellido2: &str) -> String {
    String::from(format!(
        "Espero que tenga un buen dia, {tratamiento} {apellido1}, honorable descendiente de {apellido2}."))
}

pub fn componer_saludo_informal(
    saludo_favorito: &str,
    apodo_cari√±oso: &str,
    nombre: &str,
) -> String {
    String::from(format!(
        "Mucha mierda, {saludo_favorito} {nombre} el {apodo_cari√±oso}!."
    ))
}

..//..

    let persona = Nombre_de_persona {
        nombre: "Benzirpi".to_string(),
        apellido1: "Mirvento".to_string(),
        apellido2: "Liurvine".to_string(),
        tratamiento_formal: "Mr.".to_string(),
        saludo_favorito: "querido".to_string(),
        apodo_cari√±oso: "griunquy".to_string(),
    };

    println!(
        "{}",
        componer_saludo_formal(
            &persona.tratamiento_formal,
            &persona.apellido1,
            &persona.apellido2
        )
    );
    println!(
        "{}",
        componer_saludo_informal(
            &persona.saludo_favorito,
            &persona.nombre,
            &persona.apodo_cari√±oso
        )
    );

..//..
Espero que tenga un buen dia, Mr. Mirvento, honorable descendiente de Liurve.
Mucha mierda, querido qriunquy el Benzirpi!.
```

```
pub struct Nombre_de_persona {
    pub nombre: String,
    pub apellido1: String,
    pub apellido2: String,
    pub tratamiento_formal: String,
    pub saludo_favorito: String,
    pub apodo_cari√±oso: String,
}

pub fn componer_saludo_formal(persona: &Nombre_de_persona) -> String {
    String::from(format!(
        "Espero que tenga un buen dia, {} {}, honorable descendiente de {}.",
        persona.tratamiento_formal, persona.apellido1, persona.apellido2
    ))
}

pub fn componer_saludo_informal(persona: &Nombre_de_persona) -> String {
    String::from(format!(
        "Mucha mierda, {} {} el {}!.",
        persona.saludo_favorito, persona.nombre, persona.apodo_cari√±oso
    ))
}

..//..

    let persona = Nombre_de_persona {
        nombre: "Benzirpi".to_string(),
        apellido1: "Mirvento".to_string(),
        apellido2: "Liurvine".to_string(),
        tratamiento_formal: "Mr.".to_string(),
        saludo_favorito: "querido".to_string(),
        apodo_cari√±oso: "griunquy".to_string(),
    };
    
    println!("{}", componer_saludo_formal(&persona));
    println!("{}", componer_saludo_informal(&persona));

..//..
Espero que tenga un buen dia, Mr. Mirvento, honorable descendiente de Liurvine.
Mucha mierda, querido Benzirpi el griunquy!.
```


### Structs

Como se ha comentado anteriormente, los `struct` permiten definir tipos espec√≠ficos. Pero tambi√©n pueden ir m√°s all√° e implementar m√©todos espec√≠ficos para tratar con esos tipos espec√≠ficos. Esta implementaci√≥n de m√©todos se hace utilizando la palabra reservada `impl`.

Es decir, en el fondo los struct en Rust son como las clases en los lenguajes orientados a objeto.

Por ejemplo:
```
pub struct Ascensor {
    piso_en_el_que_estoy: i16,
}

impl Default for Ascensor {
    fn default() -> Self {
        Self {
            piso_en_el_que_estoy: 0,
        }
    }
}

impl Ascensor {
    pub fn get_piso_en_el_que_esta(&self) -> i16 {
        self.piso_en_el_que_estoy
    }
}


pub struct Edificio {
    piso_mas_bajo: i16,
    piso_mas_alto: i16,
    ascensores: HashMap<i8, Ascensor>,
}

impl Edificio {
    pub fn new(
        piso_mas_bajo: i16,
        piso_mas_alto: i16,
        ascensores: HashMap<i8, Ascensor>,
    ) -> Edificio {
        Edificio {
            piso_mas_bajo: piso_mas_bajo,
            piso_mas_alto: piso_mas_alto,
            ascensores: ascensores,
        }
    }

    pub fn get_piso_mas_bajo_y_piso_mas_alto(&self) -> (i16, i16) {
        (self.piso_mas_bajo, self.piso_mas_alto)
    }

    pub fn get_cuantos_ascensores_tiene(&self) -> usize {
        self.ascensores.len()
    }

    pub fn get_iter_for_ascensores(&self) -> std::collections::hash_map::Iter<'_, i8, Ascensor> {
        self.ascensores.iter()
    }

    pub fn pulsar_llamada_del_piso(&mut self, piso: i16) -> Result<i8, String> {
        let mut distancia_mas_peque√±a = i16::MAX;
        let mut num_ascensor_mas_cercano: i8 = 1;
        for (num_ascensor, ascensor) in &self.ascensores {
            let posicion = ascensor.piso_en_el_que_estoy;
            if (piso - posicion).abs() < distancia_mas_peque√±a {
                distancia_mas_peque√±a = (piso - posicion).abs();
                num_ascensor_mas_cercano = *num_ascensor;
            }
        }
        match self.pulsar_boton_dentro_del_ascensor(num_ascensor_mas_cercano, piso) {
            Ok(_) => Ok(num_ascensor_mas_cercano),
            Err(error) => Err(error),
        }
    }

    pub fn pulsar_boton_dentro_del_ascensor(
        &mut self,
        num_ascensor: i8,
        piso_al_que_se_desea_ir: i16,
    ) -> Result<(), String> {
        if piso_al_que_se_desea_ir >= self.piso_mas_bajo
            && piso_al_que_se_desea_ir <= self.piso_mas_alto
        {
            if let Some(ascensor) = self.ascensores.get_mut(&num_ascensor) {
                ascensor.piso_en_el_que_estoy = piso_al_que_se_desea_ir;
                return Ok(());
            } else {
                return Err(format!(
                    "Este edificio no tiene ascensor {num_ascensor}, solo tiene {} ascensores",
                    self.ascensores.len()
                ));
            };
        } else {
            return Err(format!(
                "Este edificio no tiene piso {piso_al_que_se_desea_ir}, el m√°s bajo es {} y el mas alto {}",
                self.piso_mas_bajo, self.piso_mas_alto
            ));
        };
    }
}

```


### Enums

[Enums and Pattern Matching](https://doc.rust-lang.org/book/ch06-00-enums.html)

### Option

Para cuando necesitamos distinguir claramente si una variable tiene un valor (`Some`) o no lo tiene (`None`).

[The Option Enum and Its Advantages Over Null Values](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html?highlight=Option#the-option-enum-and-its-advantages-over-null-values)

### Result

Para cuando necesitamos distinguir claramente si una funci√≥n devuelve un resultado (`Ok`) o un error (`Error`).

[Error Handling](https://doc.rust-lang.org/book/ch09-00-error-handling.html)

[Recoverable Errors with Result](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html)

[Unrecoverable Errors with panic!](https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html)

[You‚Äôre Doing Exceptions Wrong - Matt Burke - NDC London 2025](https://www.youtube.com/watch?v=oWvX-hdIAQo) Conclusi√≥n extraida de esta conferencia: `Result` es con lo que Rust evita las "Vexing Exceptions" y trata los casos de "Exogenous Exceptions" en los que podemos hacer algo para mitigar la excepci√≥n; `panic` es con lo que Rust trata las "Fatal Exceptions", las "Boneheaded Exceptions" (en su primera fase, antes de corregir el bug que la causaba) y los casos de "Exogenous Exceptions" en los que no podemos hacer nada.

### ControlFlow

Para cuando necesitamos distinguir claramente entre continuar (`Continue`) o parar (`Break`).

[The ControlFlow Enum](https://doc.rust-lang.org/stable/std/ops/enum.ControlFlow.html)


### Pattern matching

[Patterns and Matching](https://doc.rust-lang.org/book/ch19-00-patterns.html?highlight=Patterns#patterns-and-matching)



## Lifetimes

[Preventing Dangling References with Lifetimes](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html)

[Lifetimes - examples](https://doc.rust-lang.org/rust-by-example/scope/lifetime.html)

Como se ha comentado antes, cada trozo de memoria es propiedad de una sola variable y se libera cuando dicha variable deja de existir. Por eso, es importante indicarle al compilador las ocasiones en que se necesite prolongar el ciclo de vida normal de alguna variable.

Normalmente, una variable solo est√° viva en el alcance (scope) donde se defina: dentro de una instancia de un `struct`, dentro de una funci√≥n `fn`, dentro de un bucle `for`, dentro de una rama condicional `if`,...

Pero, en ciertas ocasiones, puede resultar interesante ligar su ciclo de vida al de otras variables con las que ha de trabajar conjuntamente. De tal manera que todas ellas est√©n vivas durante el mismo tiempo (es decir, tengan el mismo "lifetime").


## Traits

[Traits: Defining Shared Behavior](https://doc.rust-lang.org/book/ch10-02-traits.html)

Podemos pensar en los "trait" de Rust como en los "interface" de otros lenguajes. Son un conjunto de funciones que se han de implementar con una signatura concreta. De tal forma que distintos `struct` que implementen (`impl`) ese "trait" puedan utilizarse como si fueran todos del mismo tipo. (Obviamente, solo si se utilizan las funciones del "trait" y no otras que pueda tener adem√°s cada `struct`.)

## Slices

[The Slice Type](https://doc.rust-lang.org/book/ch04-03-slices.html)

Son trozos de una colecci√≥n. Muy √∫tiles cuando se necesita trabajar con una parte de la misma en lugar de con la colecci√≥n completa.

## Iterators, Functional Iterators

Rust trabaja con formas propias de un lenguaje funcional al tratar con colecciones.

[Processing a Series of Items with Iterators](https://doc.rust-lang.org/book/ch13-02-iterators.html)

[Comparing Performance: Loops vs. Iterators](https://doc.rust-lang.org/book/ch13-04-performance.html)

[Making Code Clearer with Iterator Adapters](https://doc.rust-lang.org/book/ch13-03-improving-our-io-project.html?highlight=filter#making-code-clearer-with-iterator-adapters)

## Toolchains

Un toolchain es una versi√≥n espec√≠fica de las herramientas de Rust (components), para m√°quinas con una arquitectura espec√≠fica (targets).

[toolchains](https://rust-lang.github.io/rustup/concepts/toolchains.html)

[components in a toolchain](https://rust-lang.github.io/rustup/concepts/components.html)

[targets](https://doc.rust-lang.org/nightly/rustc/platform-support.html)

Cabe destacar que el compilador de Rust, `rustc`, tiene capacidad para cross-compilar programas para un target diferente de aquel en el que est√° corriendo. Es decir, podemos generar ejecutables para m√°quinas con arquitecturas distintas a aquella en que estamos trabajando.

[Cross-compilation](https://rust-lang.github.io/rustup/cross-compilation.html)


Algunos comandos √∫tiles:

- `rustup show`, para ver los toolchains instalados.

- `rustup default`, para fijar el toolchain a usar por defecto.


## Interoperabilidad de Rust con otros lenguajes

[The bindgen User Guide](https://rust-lang.github.io/rust-bindgen/)

[Interop with C](https://paandahl.github.io/rust-interop/c-intro.html)

[A little C with your Rust](https://docs.rust-embedded.org/book/interoperability/c-with-rust.html)

[CXX ‚Äî safe interop between Rust and C++](https://cxx.rs/)

[rust-cpp ‚Äî embed C++ code directly in Rust](https://github.com/mystor/rust-cpp)

[Foreign Function Interface](https://doc.rust-lang.org/nomicon/ffi.html)



## Algunas bibliotecas-crates-

[crates.io - The Rust community‚Äôs crate registry](https://crates.io/)

[lib.rs - The unofficial catalog of programs written in Rust](https://lib.rs/about)

[Top 10 Rust crates you must know](https://www.youtube.com/watch?v=FPRH66r-zUQ)

### standard library

[std::collections](https://doc.rust-lang.org/std/collections/)

[std::String](https://doc.rust-lang.org/std/string/struct.String.html)

[std::split](https://doc.rust-lang.org/std/primitive.str.html#method.split)

[std::Thread](https://doc.rust-lang.org/std/thread/)

[std::sync](https://doc.rust-lang.org/std/sync/index.html)

[std::channel](https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html)



### utilidades generales

[regex - Regular Expressions](https://docs.rs/regex/latest/regex/)

[anyhow - a trait object based error type for easy idiomatic error handling](https://docs.rs/anyhow/latest/anyhow/)

[thiserror - a convenient derive macro for the standard library‚Äôs std::error::Error trait](https://docs.rs/thiserror/latest/thiserror/)

[log - a lightweight logging facade](https://github.com/rust-lang/log)

[tracing - a framework for instrumenting Rust programs](https://github.com/tokio-rs/tracing)

[serde - a framework for serializing and deserializing Rust data structures efficiently and generically](https://docs.rs/serde/latest/serde/)

[serde - introduction](https://crates.io/crates/serde)

[serde - documentation](https://serde.rs/)

[num_format - producing string representations of numbers](https://docs.rs/num-format/latest/num_format/)

[json - parse and serialize JSON with ease](https://docs.rs/json/latest/json/)

[base64 - decoding and encoding](https://docs.rs/base64/latest/base64/)

[bincode - a tiny binary serialization strategy](https://docs.rs/bincode/latest/bincode/)

[chrono - operations on dates and times](https://docs.rs/chrono/latest/chrono/)

[plotters - drawing library designed for rendering figures, plots, and charts](https://docs.rs/plotters/latest/plotters/)

[image - encoding and decoding as well as some basic manipulation functions](https://docs.rs/image/latest/image/index.html)

[serialimage - extends the image crate with serializable DynamicImages](https://docs.rs/serialimage/latest/serialimage/)

[palette - linear color calculations and conversions](https://docs.rs/palette/latest/palette/)

[Tokio - an asynchronous runtime - provides the building blocks needed for writing network applications](https://tokio.rs/)

[tokio](https://docs.rs/tokio/latest/tokio/)

[RustCrypto - cryptographic algorithms](https://github.com/RustCrypto)

[printers - send files or bytes to print on unix and windows](https://docs.rs/printers/latest/printers/)

[windows-rs - let you call any Windows API](https://github.com/microsoft/windows-rs)


### i18n y l10n

[Are we i18n Yet? - The state of internazionalization in Rust](https://www.arewewebyet.org/topics/i18n/)

[rust_i18n - for loading localized text from a set of (YAML, JSON or TOML) mapping files](https://docs.rs/rust-i18n/latest/rust_i18n/index.html)

[fluent - to unleash the entire expressive power of natural language translations](https://crates.io/crates/fluent)

[fluent-bundle](https://crates.io/crates/fluent-bundle)

[gettext - safe bindings for gettext](https://crates.io/crates/gettext-rs)

### GUI

[Are we GUI Yet? - The state of building user interfaces in Rust](https://areweguiyet.com/)

[egui - a simple, fast, and highly portable immediate mode GUI library](https://crates.io/crates/egui)

[eframe - the egui framework](https://github.com/emilk/egui/tree/master/crates/eframe)

[eframe template](https://github.com/emilk/eframe_template/tree/main)

[egui file dialog](https://lib.rs/crates/egui-file-dialog)

[egui - documentation](https://docs.rs/egui/latest/egui/)

[egui - github repository](https://github.com/emilk/egui)

[egui - demo code](https://www.egui.rs/#demo)

[egui - examples](https://egui.info/examples/)

[egui - tutorial](https://whoisryosuke.com/blog/2023/getting-started-with-egui-in-rust#what-is-egui)

[iced - a cross-platform GUI library inspired by Elm](https://iced.rs/)

[iced - github repository](https://github.com/iced-rs/iced)

[iced](https://crates.io/crates/iced)

[GUI development with Rust and GTK 4](https://gtk-rs.org/gtk4-rs/stable/latest/book/)

[Ratatui - for cooking up Terminal User Interfaces](https://ratatui.rs/)

[slint - declarative GUI for Rust, C++, JavaScript & Python](https://slint.dev/)

[slint - youtube tutorial](https://www.youtube.com/watch?v=7aFgeUG9TK4)

[Tauri - Create small, fast, secure, cross-platform applications](https://tauri.app/)

[Tauri - documentation](https://tauri.app/start/)

### web

[Are we web yet? - The state of building web applications in Rust](https://www.arewewebyet.org/)

[reqwest - a higher-level HTTP Client](https://docs.rs/reqwest/latest/reqwest/index.html)

[Yew - a modern framework for creating multi-threaded front-end web apps using WebAssembly (WASM)](https://yew.rs/)

[Yew](https://docs.rs/yew/latest/yew/)

[Trunk - Build, bundle & ship your Rust WASM application to the web](https://trunkrs.dev/)

[Actix Web - web framework for backend](https://actix.rs/)

[Axum - github](https://github.com/tokio-rs/axum)

[A guide to Axum - web framework for backend](https://www.shuttle.dev/blog/2023/12/06/using-axum-rust?mode=reply)



### bases de datos

[sqlx - The async SQL toolkit for Rust](https://docs.rs/sqlx/latest/sqlx/index.html)

[sqlx - database drivers](https://docs.rs/sqlx/latest/sqlx/database/index.html)

[sqlx - Dataform SQLX](https://sqlx.dev/)

[Polars - blazingly fast DataFrame library for manipulating structured data](https://docs.pola.rs/)


### gr√°ficos

[Beby - a refreshingly simple data-driven game engine](https://github.com/bevyengine/bevy)

[Beby Engine](https://bevyengine.org/)

[integraci√≥n Bevy-egui](https://github.com/vladbat00/bevy_egui)

[three-d - a OpenGL/WebGL/OpenGL ES renderer and drawer](https://github.com/asny/three-d)

[gpu - a safe and portable graphics library based on the WebGPU API](https://wgpu.rs/)


### red - industrial - tiempo real - control

[The Rusty Bits - Youtube channel](https://www.youtube.com/@therustybits/featured)

[Floodplain - Youtube channel](https://www.youtube.com/@floodplainnl)

[Embassy - write safe, correct and energy-efficient embedded code faster](https://embassy.dev/)

[rtic - Real-Time Interrupt-driven Concurrency](https://github.com/rtic-rs/rtic)

[pnets - a framework for manipulating Petri nets](https://docs.rs/pnets/latest/pnets/)

[socketcan - using CAN bus devices](https://docs.rs/socketcan/latest/socketcan/)

[tokio_modbus - using Modbus devices](https://docs.rs/tokio-modbus/latest/tokio_modbus/)

[pcap - a packet capture library](https://docs.rs/pcap/latest/pcap/)

[pnet - a cross-platform API for low level networking](https://docs.rs/pnet/latest/pnet/)

### juegos - VR - AR

[Are we game yet? - The state of virtual reality in Rust](https://arewegameyet.rs/ecosystem/vr/#:~:text=rust-webvr.%20Safe%20rust%20API%20that%20provides%20a%20way)

[OpenVR - c++ API and runtime that allows access to VR hardware from multiple vendors](https://github.com/ValveSoftware/openvr)

[rust-penvr - high-level bindings for OpenVR](https://github.com/rust-openvr/rust-openvr)


## Algo m√°s de documentaci√≥n



### (quasi)forbiden, arcane practice

[-----Rust Koans-----](https://users.rust-lang.org/t/rust-koans/2408)
An article in The Rust Programming Language Forum

[-----The Rustonomicon-----](https://doc.rust-lang.org/nightly/nomicon/#the-rustonomicon) The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs. Should you wish a long and happy career of writing Rust programs, you should turn back now and forget you ever saw this book. 



### some assorted resources

[Why Rust?](https://rerun.io/blog/why-rust)

[The existential threat against C++ and where to go from here](https://www.youtube.com/watch?v=gG4BJ23BFBE)

[Rust in the Android platform](https://security.googleblog.com/2021/04/rust-in-android-platform.html)

[Deploy your Rust project in 20 minutes](https://www.youtube.com/watch?v=_gMzg77Qjm0)

[Let's Get Rusty - Youtube channel](https://www.youtube.com/@letsgetrusty/featured)

[8 deadly mistakes beginner Rust developers make - YouTube](https://www.youtube.com/watch?v=PbR4ECFIckg)

[Top 5 deadly Rust anti-patterns to avoid - YouTube](https://www.youtube.com/watch?v=SWwTD2neodE)

[Common Newbie Mistakes and Bad Practices in Rust](https://adventures.michaelfbryan.com/posts/rust-best-practices/bad-habits/)

[C++ RAII vs Rust OBRM - Part 1](https://www.youtube.com/watch?v=AnFaf-L_DfE) RAII (Resource Adquisition Is Initialization) vs OBRM (Ownership Based Resource Management) [C++ RAII vs Rust OBRM - Part 2](https://www.youtube.com/watch?v=7EcNkr6KFy0)

[Visualizing memory layout of Rust's data types](https://www.youtube.com/watch?v=7_o-YRxf_cc)

[How to Split Strings in Rust](https://rustjobs.dev/blog/how-to-split-strings-in-rust/)

[String Concatenation in Rust](https://rustjobs.dev/blog/string-concatenation-in-rust/)

[GUI programming with Rust](https://medium.com/digitalfrontiers/gui-programming-with-rust-c71fe4051b1a)

[Rust on an STM32 microcontroller](https://medium.com/digitalfrontiers/rust-on-a-stm32-microcontroller-90fac16f6342)

[Rust on AWS (Amazon Web Services)](https://aws.amazon.com/developer/language/rust/)

[Floating-point cheat sheet for Rust](https://floating-point-gui.de/languages/rust/)

[UUID v7 vs. v4 + Rust Programming Examples](https://www.youtube.com/watch?v=zIebRwU0FOw&list=PL7r-PXl6ZPcCIOFaL7nVHXZvBmHNhrh_Q&index=3)

[Ferrocene, mission-critical Rust](https://ferrocene.dev/en/)

[RSTY stack - Build your entire tech stack in Rust](https://youtu.be/luOgEhLE2sg)