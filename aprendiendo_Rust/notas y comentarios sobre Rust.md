# Rust


## Documentaci√≥n por la que comenzar a aprender

### Basic concepts

Two books are key:

- [The Rust Lang Book - The Rust Programming Language](https://doc.rust-lang.org/book/index.html)

- [The Cargo Book - The Rust Package Manager](https://doc.rust-lang.org/cargo/index.html)

It is very paintful to try any work without mastering these three main concepts:

- [Understanding Ownership - The Rust Programming Language](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)

- [The `Option` Enum and Its Advantages Over Null Values](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html?highlight=Option#the-option-enum-and-its-advantages-over-null-values)

- [The `Result` Enum and Error Handling in Rust](https://doc.rust-lang.org/book/ch09-00-error-handling.html)

As in any other language, it is very difficult to do anything serious without using libraries:

- [Rust Crate List - Blessed.rs - an unofficial guide to the Rust ecosystem](https://blessed.rs/crates)

- [Rust Crate List - Docs.rs - the official guide to the Rust ecosystem](https://docs.rs/)

- [Rust std library](https://doc.rust-lang.org/std/)


#### Ownership

Very important to understand it right!

[Understanding Ownership - The Rust Programming Language](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html)

[Ownership and Functions](https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#ownership-and-functions)

[References and Borrowing](https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html)

[Understanding Ownership - Brown University](https://rust-book.cs.brown.edu/ch04-00-understanding-ownership.html)

[Rust Does Not Permit Manual Memory Management](https://rust-book.cs.brown.edu/ch04-01-what-is-ownership.html#rust-does-not-permit-manual-memory-management)

[References and Borrowing](https://rust-book.cs.brown.edu/ch04-02-references-and-borrowing.html)

[RustOwl, a new tool for visualizing Rust lifetimes - Let's Get Rusty - Youtube](https://youtu.be/NV6Xo_el_2o)

[RustOwl tool - Github](https://github.com/cordx56/rustowl)



### Hands-on learning

If you want to start practicing without installing anything, you can try Rust online with (https://play.rust-lang.org/). 

If you want to start serious, install `rustup` (https://doc.rust-lang.org/book/ch01-01-installation.html) and use `cargo` (https://doc.rust-lang.org/cargo/getting-started/first-steps.html). If you are using [Visual Studio Code](https://code.visualstudio.com/download) as IDE, you can use it with the [Rust.analyzer extension](https://rust-analyzer.github.io)

Some resources and tutorials:

[Working the Rust Lang Book](https://www.youtube.com/playlist?list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8) - Let's Get Rusty - YouTube

[Rust By Example](https://doc.rust-lang.org/rust-by-example/index.html)

[Rust Cookbook](https://rust-lang-nursery.github.io/rust-cookbook/intro.html)

[GitHub - mre-idiomatic-rust - ü¶Ä ](https://github.com/mre/idiomatic-rust)
A peer-reviewed collection of articles-talks-repos which teach concise, idiomatic Rust.

[GitHub - rust-lang-rustlings- ü¶Ä ](https://github.com/rust-lang/rustlings)Small exercises to get you used to reading and writing Rust code!

[A half-hour to learn Rust](https://fasterthanli.me/articles/a-half-hour-to-learn-rust)

[Getting started with Rust. A brief Introduction to the language - YouTube](https://www.youtube.com/watch?v=4q3Z5RBX7hQ)

[Learn Rust Programming - Complete Course ü¶Ä - freeCodeCamp - YouTube](https://www.youtube.com/watch?v=BpPEoZW5IiY)

[google-comprehensive-rust-](https://github.com/google/comprehensive-rust) This is the Rust course used by the Android team at Google. The course covers all aspects of Rust, from basic syntax to generics and error handling. It also includes deep dives on Android, Chromium, bare-metal, and concurrency. [Syllabus](https://google.github.io/comprehensive-rust/)

[Practical Rust Web Development](https://dev.to/werner/practical-rust-web-development-api-rest-29g1)

[Zero To Production in Rust - an opinionated introduction to backend development in Rust](https://www.zero2prod.com/index.html)


#### If you like to program GUI (Graphic User Interface) based programs instead of CLI (Command Line Interface) based ones

Here are some sugestions:

[Are we GUI yet](https://areweguiyet.com/)

[egui - an easy-to-use immediate mode GUI in pure Rust - documentation](https://docs.rs/egui/latest/egui/)

[egui - an easy-to-use immediate mode GUI in pure Rust - Github repository](https://github.com/emilk/egui)

[egui - Getting started with egui in Rust](https://whoisryosuke.com/blog/2023/getting-started-with-egui-in-rust)

[egui - Some sample code - Demo](https://www.egui.rs/#demo)

[iced - A cross-platform GUI library for Rust, inspired by Elm - documentation](https://docs.rs/iced/latest/iced/)

[iced ‚Äì A cross-platform GUI library for Rust, inspired by Elm - Github repository](https://github.com/iced-rs/iced)

[Yew - A framework for creating reliable and efficient web applications](https://yew.rs/)

[Trunk - Build, bundle & ship your Rust WASM application to the web](https://trunkrs.dev/)

[Building a Rust App With Yew! - Let's Get Rusty - Youtube](https://www.youtube.com/watch?v=KmOeFrwz8BM)


### some additional books and practical resources

[Let's Get Rusty - Youtube channel](https://www.youtube.com/@letsgetrusty)

[Clippy - The Rust Linter](https://doc.rust-lang.org/clippy/)

[Rust Design Patterns](https://rust-unofficial.github.io/patterns/intro.html)

[Iterators in Rust](https://dev.to/francescoxx/iterators-in-rust-fm)

[Cargo Workspaces](https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html)

[mdBook, a command line tool to create books with Markdown](https://rust-lang.github.io/mdBook/)

[The Embedded Rust Book](https://docs.rust-embedded.org/book/)



### Some additional material to read/view

[Rust Is Easy - just read the compiler error messages  ;-) - YouTube](https://www.youtube.com/watch?v=CJtvnepMVAU)

[Getting familiar with Rust's syntax - YouTube](https://www.youtube.com/watch?v=AuzoABH7fRA)

[Simple error handling in Rust - YouTube](https://www.youtube.com/watch?v=g6WUHcyjsfc)

[The magic of Rust's type system - Youtube](https://www.youtube.com/watch?v=NDIU1GSBrVI)

[Learning Rust: Memory, Ownership and Borrowing - Youtube](https://www.youtube.com/watch?v=8M0QfLUDaaA)

[Why Rust?](https://rerun.io/blog/why-rust)

[Rust stole C++'s best features - YouTube](https://www.youtube.com/watch?v=sjsnuirLyKM)

[pretzelhammer-rust-blog - Github](https://github.com/pretzelhammer/rust-blog/blob/master/posts/tour-of-rusts-standard-library-traits.md)

[5 traits your Rust types must implement](https://www.youtube.com/watch?v=Nzclc6MswaI)

[The genius of Rust constructors - Youtube](https://www.youtube.com/watch?v=6mVkva3_z9M)

[The size of your variables matters - Youtube](https://www.youtube.com/watch?v=hwyRnHA54lI)

[8 deadly mistakes beginner Rust developers make - YouTube](https://www.youtube.com/watch?v=PbR4ECFIckg)

[Top 5 deadly Rust anti-patterns to avoid - YouTube](https://www.youtube.com/watch?v=SWwTD2neodE)

[Common Newbie Mistakes and Bad Practices in Rust](https://adventures.michaelfbryan.com/posts/rust-best-practices/bad-habits/)


## Strong typed

https://doc.rust-lang.org/book/ch03-02-data-types.html

Rust es un lenguaje "fuertemente tipado". El compilador se encarga de revisar el uso de valores del tipo adecuado en todo momento.

Por ejemplo, en Rust no se pueden sumar un `i32` y un `f32`. Para hacerlo es necesario indicar expresamente cu√°l se convierte de tipo, para saber con claridad cu√°l ser√° el tipo resultante.

```
## esta suma:

    let resultado = 5 + 2.3;
    
## produce:

error[E0277]: cannot add a float to an integer
  --> src/main.rs:14:23
   |
14 |     let resultado = 5 + 2.3;
   |                       ^ no implementation for `{integer} + {float}`
   |
   = help: the trait `Add<{float}>` is not implemented for `{integer}`
   = help: the following other types implement trait `Add<Rhs>`:
             <&'a f128 as Add<f128>>
             <&'a f16 as Add<f16>>
             <&'a f32 as Add<f32>>
             <&'a f64 as Add<f64>>
             <&'a i128 as Add<i128>>
             <&'a i16 as Add<i16>>
             <&'a i32 as Add<i32>>
             <&'a i64 as Add<i64>>
           and 56 others

For more information about this error, try `rustc --explain E0277`.
```

Por eso, o bien los tipos resultantes se han de poder inferir con claridad por los tipos participantes en la operaci√≥n, o bien se han de realizar expresamente las conversiones que sean necesarias.

```
    let resultado = 5 + 2.3 as i32;

## o

    let resultado = 5 as f32 + 2.3;
    
## o

    let resultado = 5.0 + 2.3;
```

Parece una tonteria, pero los redondeos en la representaci√≥n interna pueden tener consecuencias en seg√∫n qu√© aplicaciones. 

https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf

Rust nos obliga a pensar en c√≥mo estamos utilizando los valores que manejamos. En las implicaciones que puede tener usar un tipo de representaci√≥n u otro.

En el fondo, los ordenadores  lo reducen todo a valores digitales 0|1 y esas traducciones a binario o desde binario tienen su importancia en seg√∫n qu√© ocasiones.

https://doc.rust-lang.org/book/ch04-03-slices.html?highlight=string#string-slices

https://doc.rust-lang.org/book/ch08-02-strings.html

https://doc.rust-lang.org/book/ch08-02-strings.html#bytes-and-scalar-values-and-grapheme-clusters-oh-my


### Un consejo: definir tipos espec√≠ficos

Una vez acostumbrados al tipado fuerte del propio lenguaje. Podemos ir m√°s all√° y definir tipos espec√≠ficos para nuestra aplicaci√≥n, usando `struct`. 

Los tipos espec√≠ficos tienen una doble ventaja: 
- Permiten referirse a cada cosa por su nombre 
- Evitan errores al pasar valores como par√°metros. 

Por ejemplo: no es lo mismo 
```
    pub fn calcular_precio_del_helado(precio_base: f32, temperatura: f32) -> f32 {
        ((precio_base + temperatura * 0.02) * 100.0).round() / 100.0
    }
```
que
```
    pub struct Temperatura {
        pub cantidad: f32,
    }
    
    pub struct Dinero {
        pub cantidad: f32,
    }
    
    pub fn calcular_precio_del_helado(precio_base: Dinero, temperatura: Temperatura) -> Dinero {
        Dinero {
            cantidad: ((precio_base.cantidad + temperatura.cantidad * 0.02) * 100.0).round() / 100.0,
        }
    }
```

En el primer caso, podr√≠amos confundirnos y pasar el valor de la temperatura como precio y el del precio como temperatura:
```
    println!("{}", calcular_precio_del_helado(75.0, 22.4));
    
    println!("{}", calcular_precio_del_helado(22.4, 75.0));

```


Pero en el segundo caso es mucho m√°s dif√≠cil que eso suceda:
```
    println!(
        "{}",
        calcular_precio_del_helado(Dinero { cantidad: 75.0 }, Temperatura { cantidad: 22.4 })
            .cantidad
    );

    println!(
        "{}",
        calcular_precio_del_helado(Dinero { cantidad: 22.4 }, Temperatura { cantidad: 75.0 })
            .cantidad
    );

```

Adem√°s, definir tipos espec√≠ficos nos permite a√±adir m√°s campos al `struct`, m√°s concreci√≥n en el tipo. Como, por ejemplo, indicando la unidad de medida para cada cantidad.
```
pub struct Temperatura {
    pub cantidad: f32,
    pub unidad_de_medida: UnidadParaMedirTemperatura,
}
pub enum UnidadParaMedirTemperatura {
    Celsius,
    Farenheit,
}

pub struct Dinero {
    pub cantidad: f32,
    pub moneda: Moneda,
}
pub enum Moneda {
    EUR,
    USD,
    CAD,
    GPB,
    JPY,
    RUB,
    RMB,
}
```

Esto permite que el compilador nos ayude. Con errores como, por ejemplo:
```
error[E0063]: missing field `unidad_de_medida` in initializer of `Temperatura`
  --> src/main.rs:18:65
   |
18 |         calcular_precio_del_helado(&Dinero { cantidad: 75.0 }, &Temperatura { cantidad: 22.4 })
   |                                                                 ^^^^^^^^^^^ missing `unidad_de_medida`

For more information about this error, try `rustc --explain E0063`.
```

Estos errores evitan usar datos incompletos. En el ejemplo, el c√≥digo no compilar√≠a hasta indicar las unidades de medida:
```
    println!(
        "{}",
        calcular_precio_del_helado(
            &Dinero {
                cantidad: 75.0,
                moneda: Moneda::EUR
            },
            &Temperatura {
                cantidad: 22.4,
                unidad_de_medida: UnidadParaMedirTemperatura::Celsius
            }
        )
        .cantidad
    );
```

Otro ejemplo:
```
pub fn componer_saludo_formal(tratamiento: &str, apellido1: &str, apellido2: &str) -> String {
    String::from(format!(
        "Espero que tenga un buen dia, {tratamiento} {apellido1}, honorable descendiente de {apellido2}."))
}

pub fn componer_saludo_informal(
    saludo_favorito: &str,
    apodo_cari√±oso: &str,
    nombre: &str,
) -> String {
    String::from(format!(
        "Mucha mierda, {saludo_favorito} {nombre} el {apodo_cari√±oso}!."
    ))
}

..//..

    let persona = Nombre_de_persona {
        nombre: "Benzirpi".to_string(),
        apellido1: "Mirvento".to_string(),
        apellido2: "Liurvine".to_string(),
        tratamiento_formal: "Mr.".to_string(),
        saludo_favorito: "querido".to_string(),
        apodo_cari√±oso: "griunquy".to_string(),
    };

    println!(
        "{}",
        componer_saludo_formal(
            &persona.tratamiento_formal,
            &persona.apellido1,
            &persona.apellido2
        )
    );
    println!(
        "{}",
        componer_saludo_informal(
            &persona.saludo_favorito,
            &persona.nombre,
            &persona.apodo_cari√±oso
        )
    );

..//..
Espero que tenga un buen dia, Mr. Mirvento, honorable descendiente de Liurve.
Mucha mierda, querido qriunquy el Benzirpi!.
```

```
pub struct Nombre_de_persona {
    pub nombre: String,
    pub apellido1: String,
    pub apellido2: String,
    pub tratamiento_formal: String,
    pub saludo_favorito: String,
    pub apodo_cari√±oso: String,
}

pub fn componer_saludo_formal(persona: &Nombre_de_persona) -> String {
    String::from(format!(
        "Espero que tenga un buen dia, {} {}, honorable descendiente de {}.",
        persona.tratamiento_formal, persona.apellido1, persona.apellido2
    ))
}

pub fn componer_saludo_informal(persona: &Nombre_de_persona) -> String {
    String::from(format!(
        "Mucha mierda, {} {} el {}!.",
        persona.saludo_favorito, persona.nombre, persona.apodo_cari√±oso
    ))
}

..//..

    let persona = Nombre_de_persona {
        nombre: "Benzirpi".to_string(),
        apellido1: "Mirvento".to_string(),
        apellido2: "Liurvine".to_string(),
        tratamiento_formal: "Mr.".to_string(),
        saludo_favorito: "querido".to_string(),
        apodo_cari√±oso: "griunquy".to_string(),
    };
    
    println!("{}", componer_saludo_formal(&persona));
    println!("{}", componer_saludo_informal(&persona));

..//..
Espero que tenga un buen dia, Mr. Mirvento, honorable descendiente de Liurvine.
Mucha mierda, querido Benzirpi el griunquy!.
```


### Structs

Como se ha comentado anteriormente, los `struct` permiten definir tipos espec√≠ficos. Pero tambi√©n pueden ir m√°s all√° e implementar m√©todos espec√≠ficos para tratar con esos tipos espec√≠ficos. Esta implementaci√≥n de m√©todos se hace utilizando la palabra reservada `impl`.

Es decir, en el fondo los struct en Rust son como las clases en los lenguajes orientados a objeto.

Por ejemplo:
```
pub struct Ascensor {
    piso_en_el_que_estoy: i16,
}

impl Default for Ascensor {
    fn default() -> Self {
        Self {
            piso_en_el_que_estoy: 0,
        }
    }
}

impl Ascensor {
    pub fn get_piso_en_el_que_esta(&self) -> i16 {
        self.piso_en_el_que_estoy
    }
}


pub struct Edificio {
    piso_mas_bajo: i16,
    piso_mas_alto: i16,
    ascensores: HashMap<i8, Ascensor>,
}

impl Edificio {
    pub fn new(
        piso_mas_bajo: i16,
        piso_mas_alto: i16,
        ascensores: HashMap<i8, Ascensor>,
    ) -> Edificio {
        Edificio {
            piso_mas_bajo: piso_mas_bajo,
            piso_mas_alto: piso_mas_alto,
            ascensores: ascensores,
        }
    }

    pub fn get_piso_mas_bajo_y_piso_mas_alto(&self) -> (i16, i16) {
        (self.piso_mas_bajo, self.piso_mas_alto)
    }

    pub fn get_cuantos_ascensores_tiene(&self) -> usize {
        self.ascensores.len()
    }

    pub fn get_iter_for_ascensores(&self) -> std::collections::hash_map::Iter<'_, i8, Ascensor> {
        self.ascensores.iter()
    }

    pub fn pulsar_llamada_del_piso(&mut self, piso: i16) -> Result<i8, String> {
        let mut distancia_mas_peque√±a = i16::MAX;
        let mut num_ascensor_mas_cercano: i8 = 1;
        for (num_ascensor, ascensor) in &self.ascensores {
            let posicion = ascensor.piso_en_el_que_estoy;
            if (piso - posicion).abs() < distancia_mas_peque√±a {
                distancia_mas_peque√±a = (piso - posicion).abs();
                num_ascensor_mas_cercano = *num_ascensor;
            }
        }
        match self.pulsar_boton_dentro_del_ascensor(num_ascensor_mas_cercano, piso) {
            Ok(_) => Ok(num_ascensor_mas_cercano),
            Err(error) => Err(error),
        }
    }

    pub fn pulsar_boton_dentro_del_ascensor(
        &mut self,
        num_ascensor: i8,
        piso_al_que_se_desea_ir: i16,
    ) -> Result<(), String> {
        if piso_al_que_se_desea_ir >= self.piso_mas_bajo
            && piso_al_que_se_desea_ir <= self.piso_mas_alto
        {
            if let Some(ascensor) = self.ascensores.get_mut(&num_ascensor) {
                ascensor.piso_en_el_que_estoy = piso_al_que_se_desea_ir;
                return Ok(());
            } else {
                return Err(format!(
                    "Este edificio no tiene ascensor {num_ascensor}, solo tiene {} ascensores",
                    self.ascensores.len()
                ));
            };
        } else {
            return Err(format!(
                "Este edificio no tiene piso {piso_al_que_se_desea_ir}, el m√°s bajo es {} y el mas alto {}",
                self.piso_mas_bajo, self.piso_mas_alto
            ));
        };
    }
}

```


### Enums

### Option

### Result

### Pattern matching

## Ownership , Borrow-checker

### Move semantics

## Lifetimes

## Traits

## Slices

## Iterators

### Functional iterators



## Algo m√°s de documentaci√≥n



### (quasi)forbiden, arcane practice

[-----Rust Koans-----](https://users.rust-lang.org/t/rust-koans/2408)
An article in The Rust Programming Language Forum

[-----The Rustonomicon-----](https://doc.rust-lang.org/nightly/nomicon/#the-rustonomicon) The Rustonomicon digs into all the awful details that you need to understand when writing Unsafe Rust programs. Should you wish a long and happy career of writing Rust programs, you should turn back now and forget you ever saw this book. 


### some assorted resources

[Why Rust?](https://rerun.io/blog/why-rust)

[The existential threat against C++ and where to go from here](https://www.youtube.com/watch?v=gG4BJ23BFBE)

[Rust in the Android platform](https://security.googleblog.com/2021/04/rust-in-android-platform.html)

[Deploy your Rust project in 20 minutes](https://www.youtube.com/watch?v=_gMzg77Qjm0)

[Let's Get Rusty - Youtube channel](https://www.youtube.com/@letsgetrusty/featured)

[8 deadly mistakes beginner Rust developers make - YouTube](https://www.youtube.com/watch?v=PbR4ECFIckg)

[Top 5 deadly Rust anti-patterns to avoid - YouTube](https://www.youtube.com/watch?v=SWwTD2neodE)

[Common Newbie Mistakes and Bad Practices in Rust](https://adventures.michaelfbryan.com/posts/rust-best-practices/bad-habits/)

[C++ RAII vs Rust OBRM - Part 1](https://www.youtube.com/watch?v=AnFaf-L_DfE) RAII (Resource Adquisition Is Initialization) vs OBRM (Ownership Based Resource Management) [C++ RAII vs Rust OBRM - Part 2](https://www.youtube.com/watch?v=7EcNkr6KFy0)

[Visualizing memory layout of Rust's data types](https://www.youtube.com/watch?v=7_o-YRxf_cc)

[How to Split Strings in Rust](https://rustjobs.dev/blog/how-to-split-strings-in-rust/)

[String Concatenation in Rust](https://rustjobs.dev/blog/string-concatenation-in-rust/)

[GUI programming with Rust](https://medium.com/digitalfrontiers/gui-programming-with-rust-c71fe4051b1a)

[Rust on an STM32 microcontroller](https://medium.com/digitalfrontiers/rust-on-a-stm32-microcontroller-90fac16f6342)

[Rust on AWS (Amazon Web Services)](https://aws.amazon.com/developer/language/rust/)

[Floating-point cheat sheet for Rust](https://floating-point-gui.de/languages/rust/)

[UUID v7 vs. v4 + Rust Programming Examples](https://www.youtube.com/watch?v=zIebRwU0FOw&list=PL7r-PXl6ZPcCIOFaL7nVHXZvBmHNhrh_Q&index=3)

[Ferrocene, mission-critical Rust](https://ferrocene.dev/en/)

[RSTY stack - Build your entire tech stack in Rust](https://youtu.be/luOgEhLE2sg)